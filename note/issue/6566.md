## https://github.com/vuejs/core/issues/6568

stringifyStatic 字符串化后的
```html
<script setup>
import { ref, watch } from 'vue'
const foo = ref()
const bar = ref()
</script>

<template>
  <select v-model="foo">
    <option :value="1">One</option>
    <option :value="2">Two</option>
    <option :value="3">Three</option>
    <option :value="4">Four</option>
    <option :value="5">Four</option>
  </select>
</template>
```
会丢失value上的数字类型
```javaScript
const _hoisted_1 = /*#__PURE__*/_createStaticVNode("<option value=\"1\">One</option><option value=\"2\">Two</option><option value=\"3\">Three</option><option value=\"4\">Four</option><option value=\"5\">Five</option>", 5)
const _hoisted_6 = [
  _hoisted_1
]
```
为什么会取消掉类型呢，hoisted_1会直接被innerHtml插入到document中，此时type无论你设置是value=1还是value=“1”，都会被浏览器自动变成string类型“1”

然鹅，如果取消stringifyStatic,则类型就会得到保留，详见:
```javascript
const _hoisted_1 = /*#__PURE__*/_createElementVNode("option", { value: "1" }, "One", -1 /* HOISTED */)
const _hoisted_2 = /*#__PURE__*/_createElementVNode("option", { value: 2 }, "Two", -1 /* HOISTED */)
const _hoisted_3 = /*#__PURE__*/_createElementVNode("option", { value: 3 }, "Three", -1 /* HOISTED */)
const _hoisted_4 = /*#__PURE__*/_createElementVNode("option", { value: 4 }, "Four", -1 /* HOISTED */)
const _hoisted_5 = [
  _hoisted_1,
  _hoisted_2,
  _hoisted_3,
  _hoisted_4
]
```

经过调研发现，无论是否经过字符串化，二者render函数都长一个样
```typescript
return (_ctx, _cache) => {
  return _withDirectives((_openBlock(), _createElementBlock("select", {
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((foo).value = $event))
  }, _hoisted_6, 512 /* NEED_PATCH */)), [
    [_vModelSelect, foo.value]
  ])
}
```
注意到cache[0]
因此有了解决方案1,在运行时改变onChange内部的$event类型
```typescript
_cache[0] = $event => ((foo).value = toNumber($event)) //如果绑定的类型是Number
```
但这种方案是不可行的，因为$event始终返回的是字符串类型的值,为什么呢？
和浏览器机制相关：
因为对于innerHtml,value=1或者value=“1” 都会被强制转换成value=“1”，这样就会导致类型不稳定了
程序无法判断被html粗暴过滤成字符串化后的value的原本类型。

解决方案2，直接取消select的stringifyStatic，可行但过于粗暴，是否有更好地方案？

解决方案3:看看是否能从render别的方面入手，目前看到的[_vModelSelect, foo.value]可能是个突破口
调研发现，[_vModelSelect, foo.value]任然是运行时的解决方案，但这个bug在运行时是无法解决的。
