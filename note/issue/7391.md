```javascript
 test('with teleport(change subTree)', async () => {
    document.body.innerHTML = ''
    const state = reactive({ color: 'red' })
    const root = document.createElement('div')
    const target = document.body
    const toggle = ref(true)
//transition生成的vnode是一个函数式组件虚拟节点，type是一个函数，执行后会返回真正的Transition vnode
    const App = {
      setup() {
        useCssVars(() => state)
        return () =>
          h(
            Teleport,
            { to: target },
            h(Transition, () => {
              return toggle.value ? h('p') : null
            })
          )
      }
    }

    render(h(App), root)
    await nextTick()

    for (const c of [].slice.call(target.children as any)) {
      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe('red')
    }

    toggle.value = false
    await nextTick()
    toggle.value = true
    await nextTick()

    for (const c of [].slice.call(target.children as any)) {
      expect((c as HTMLElement).style.getPropertyValue(`--color`)).toBe('red')
    }
  })
  ```

  一、
注意teleportImpl最后有一个updateCssVars兜底
  ```js
  export const TeleportImpl = {
  __isTeleport: true,
  process(
    n1: TeleportVNode | null,
    n2: TeleportVNode,
    //...
  ) {

    //中间一堆子节点挂载操作

    updateCssVars(n2)
  },
  ```